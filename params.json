{"name":"SUSI","tagline":"SUSI, a Universal System Interface","body":"![Image of SUSI](http://webvariants.github.io/susi/resources/SUSI_Icon.svg)\r\n# SUSI, a Universal System Interface\r\n\r\nSUSI is an application framework to build interfaces for arbitrary systems.\r\n\r\nIt intends to enable even novice programmers to build robust asyncronous applications on both ends of the system: front-end and back-end.\r\n\r\n## Getting started\r\n\r\n### 1. Clone\r\nFirst, clone the repo and its submodules from [Github](https://github.com/webvariants/susi)\r\n```\r\ngit clone --recursive https://github.com/webvariants/susi\r\n```\r\n\r\n### 2. Build\r\nSUSI's build process is *CMake* based. Therefore simply build with **cmake**.\r\n\r\nAfter building, install the libraries and binaries and run ldconfig to update your shared library cache.\r\n```\r\ncd $SUSI\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake -j4\r\nsudo make install\r\nsudo ldconfig\r\n```\r\n\r\n### 3. Start the SUSI core server\r\nThe main component of SUSI is its *core server* for handling the entire event dispatching and serves as a communication base for all other components.\r\n\r\nYou need to specify a valid TLS key / certificate pair to start the server.\r\nTo create a self-signed certificate run the following command:\r\n```\r\nopenssl req -nodes -x509 -newkey rsa:2048 -keyout server_key.pem -out server_cert.pem -days 36500\r\n```\r\nFollowing, you can start the SUSI core server:\r\n```\r\nsusi-core --key server_key.pem --cert server_cert.pem --port 4000\r\n```\r\nNow the SUSI core server is accepting TLS-connection on port 4000\r\n\r\n#### Start one or more services\r\nOnce your core server has been started, you can start other components that connect to it.\r\n\r\nFor our first example lets start with susi-duktape - our server side javascript interpreter.\r\n\r\nCreate a Javascript source file, which looks like this:\r\n```javascript\r\nsusi.registerProcessor('.*', function (evt) {\r\n\tconsole.debug('in processor');\r\n\tevt.payload = {};\r\n\tsusi.ack(evt);\r\n});\r\n\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 1');\r\n\tevt.payload.a = 'foo';\r\n\tsusi.ack(evt);\r\n});\r\n\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 2');\r\n\tevt.payload.b = 'bar';\r\n\tsusi.dismiss(evt);\r\n});\r\n\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 3 (should never be called)');\r\n\tevt.payload.c = 'baz';\r\n\tsusi.ack(evt);\r\n});\r\n\r\nsusi.registerConsumer('foo', function (evt) {\r\n\tconsole.log('consumer:', evt.payload);\r\n});\r\n\r\nsusi.publish({ topic: 'foo' }, function (evt) {\r\n\tconsole.log('finish:', evt.payload);\r\n});\r\n\r\n```\r\nPlace this file somewhere in your filesystem with the name *susi-sample.js*.\r\n\r\nYou can use the same key/certificate pair you used to start the server, but you can create another pair:\r\n```\r\nopenssl req -nodes -x509 -newkey rsa:2048 -keyout duktape_key.pem -out duktape_cert.pem -days 36500\r\n```\r\nNow its time to start *susi-duktape*.\r\n```\r\nsusi-duktape --src susi-sample.js --addr localhost --port 4000 --key duktape_key.pem --cert duktape_cert.pem\r\n> started Susi::duktape engine and loaded source.js\r\n> 2015-08-25T09:35:31.934Z DBG susi-js: source.js:2: in processor\r\n> 2015-08-25T09:35:31.934Z DBG susi-js: source.js:8: in foo proc 1\r\n> 2015-08-25T09:35:31.934Z DBG susi-js: source.js:14: in foo proc 2\r\n> 2015-08-25T09:35:31.934Z INF susi-js: consumer: {a:\"foo\",b:\"bar\"}\r\n> 2015-08-25T09:35:31.935Z INF susi-js: finish: {a:\"foo\",b:\"bar\"}\r\n```\r\nIf you see an output like this, everything's fine :)\r\nIf you take a look at the supplied JS sources, you can see how SUSI works.\r\n\r\n### 4. Understand the code\r\nThere are 5 essential actions you need to know about:\r\n\r\n* **registerProcessor()**\r\n\t* This attaches an active event handler to a specific topic.\r\n\t* All active event handlers run sequentially in the order of their declaration.\r\n* **registerConsumer()**\r\n\t* This attaches a passive event handler to a specific topic\r\n\t* All passive event handlers will run after all active event handlers have finished.\r\n* **publish()**\r\n\t* This publishes an event.\r\n\t* The event is firstly processed by all processors\r\n\t* After all processors finished, the consumers for this topic are called\r\n* **ack()**\r\n\t* This needs to be called when a processor finished.\r\n\t* It tells susi, to continue with the event processing.\r\n* **dismiss()**\r\n\t* This can also be called if a processor finished\r\n\t* It tells SUSI to stop the event processing -> no active handlers will be called after this\r\n\t* It will NOT stop passive handlers or the finish callback from being called\r\n\r\nAs you see in the example, we register four processors:\r\n\r\n```javascript\r\nsusi.registerProcessor('.*', function (evt) {\r\n\tconsole.debug('in processor');\r\n\tevt.payload = {};\r\n\tsusi.ack(evt);\r\n});\r\n```\r\nThis is the first processor. It takes a string/regex to specify the event topic the processor is interested in,\r\nand a callback which is called. The first processor matches all events (topic: \".*\") and ensures that the\r\nevent payload is an empty object. Notice that we call ack() at the end, to tell SUSI that the event can be processed by other processors now.\r\n\r\n\r\n```javascript\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 1');\r\n\tevt.payload.a = 'foo';\r\n\tsusi.ack(evt);\r\n});\r\n```\r\nThis is the second processor. It matches all events with the topic 'foo' and attaches the string 'foo' to the payload field 'a'. After this it acknowledges the event back to SUSI.\r\n\r\n```javascript\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 2');\r\n\tevt.payload.b = 'bar';\r\n\tsusi.dismiss(evt);\r\n});\r\n```\r\nThe third processor matches all events with the topic 'foo' as well.\r\nNotice that we call dismiss() at the end of the callback. This prevents all later declared processors to be called.\r\n\r\n```javascript\r\nsusi.registerProcessor('foo', function (evt) {\r\n\tconsole.debug('in foo proc 3 (should never be called)');\r\n\tevt.payload.c = 'baz';\r\n\tsusi.ack(evt);\r\n});\r\n```\r\nThis is the fourth processor. It will never be called due to the dismiss() statement in the third processor.\r\n\r\n```javascript\r\nsusi.registerConsumer('foo', function (evt) {\r\n\tconsole.log('consumer:', evt.payload);\r\n});\r\n```\r\nHere we declare a Consumer / passive event handler.\r\nIt gets called after all processors, that are interested in this event, have finished.\r\nIn the callback we simply log the event payload to stdout.\r\n\r\n```javascript\r\nsusi.publish({ topic: 'foo' }, function (evt) {\r\n\tconsole.log('finish:', evt.payload);\r\n});\r\n```\r\nNow, after the setup of all those processors and consumers, we can finally publish an event!\r\npublish() takes the event as first parameter. All events HAVE TO contain a topic field. Additionally they can have a payload field which can contain arbitrary data. As a second argument you can specify a finish callback. This is somewhat a one-time-consumer. It gets called after all processors for this event finished, but gets immediatly deleted afterwards.\r\n\r\n### 5. Learn More about SUSI\r\n* Documentation @ [susi.readme.io](http://susi.readme.io/).\r\n* [Libraries](https://github.com/webvariants/susi/blob/experimental/LIBRARIES.md)\r\n  * [Boost](https://github.com/boostorg/boost)\r\n  * [OpenSSL](https://github.com/openssl/openssl)\r\n\r\n### 6. Stay in contact\r\n* Homepage: http://susi.io\r\n* e-mail: tino[*dot*]rusch[*at*]webvariants[*dot*]de\r\n\r\n\r\nSUSI is released under the [MIT License](https://github.com/webvariants/susi/blob/experimental/LICENSE.md).\r\n\r\n*Many thanks to the whole SUSIProject Team and all [contributors](https://github.com/webvariants/susi/graphs/contributors) and especially to Anja Pydde for designing our great logo!*\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}